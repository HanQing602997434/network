
//网络IO管理
/*
    网络IO，会涉及到两个系统对象，一个是用户空间调用IO的进程或者线程，另一个是内核空间
    的内核系统，比如发生IO操作read时，它会经历两个阶段：
    1.等待数据准备就绪
    2.将数据从内核拷贝到进程或者线程中
    因此在以上两个阶段上各种不同的情况，所以出现了多种网络IO模型

    五种网络IO模型

    阻塞IO
    在linux中，默认情况下所有socket都是blocking，一个典型的读操作流程：
    当用户进程调用了read这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于
    network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的数据包），
    这个时候kernel就要等待足够的数据到来。而用户进程这边，整个进程会被阻塞。当kernel
    一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，
    用户进程才解除block的状态，重新运行起来。
        所以blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都
    被block了。
    一问一答服务器/客户端模型：
    服务器：socket()->bind()->accept->recv()->send()
    客户端：socket()->connect()->send()->recv()
    
        大部分的socket接口都是阻塞型的。所谓阻塞型接口是指系统调用（一般是IO接口）不返回
    调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返回。
        实际上，除非特别指定，几乎所有的IO接口（包括socket接口）都是阻塞型的。这给网络编
    程带来了一个很大的问题，如在调用send()的同时，线程将被阻塞，在此期间，线程将无法执行
    任何运算或响应任何网络请求。
        一个简单的改进方案是在服务器端使用多线程（或多进程）。多线程（多进程）的目的是让
    每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。具体
    使用多进程还是多线程，并没有一个特定的模式。传统意义上，进程的开销要远远大于线程，所
    以如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服务执行体需要较多
    的CPU资源，譬如需要进行大规模或长时间的数据运算或文件访问，则进程较为安全。通常，使
    用pthread_create()创建新线程，fork()创建新进程。
    对上述服务器/客户端模型提出更高的要求，即让服务器同时为多个客户机提供一问一答的模型：
    服务器：socket()->bind()->accept()->pthread_create()->recv()->send()
    客户端：socket()->connect()->send()->recv()

    在上述的线程/时间图例中，主程序持续等待客户端的连接请求，如果有连接，则创建新线程，并在
    新线程中提供为前例同样的问答服务。
        很多初学者不明白为何一个socket可以accept多次。实际上socket的设计者可能特意为多客户
    机的情况留下了伏笔，让accept()能够返回一个新的socket。下面是accept接口的原型：
        int accept(int s, struct sockaddr *addr, socklen_t *addrlen);
    输入参数s是从socket(),bind()和listen()中沿用下来的socket句柄值。执行完bind()和listen()
    后，操作系统已经开始在指定的端口处监听所有的连接请求，如果有请求，则将该连接请求加入请求队
    列。调用accept()接口正是从socket s的请求队列抽取第一个连接信息，创建一个与s同类的新的socket
    返回句柄。新的socket句柄即是后续read()和recv()的输入参数。如果请求队列当前没有请求，则
    accept()将进入阻塞状态直到有请求进入队列。
        上述多线程的服务器模型似乎完美的解决了为多个客户机提供问答请求的要求，但其实并不尽然。
    如果要同时响应成百上千的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对
    外界响应效率，而线程和进程本身也更容易进入假死状态。
        很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在减少创建和销毁线程的频率，其
    维护一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量
    重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用
    很多大型系统，如websphere、tomcat和各种数据库等。但是，“线程池”和“连接池”技术也只有在一定
    程度上缓解了频繁调用IO接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，
    “池”构成的系统对外界的响应并不比没有池的时候效果好多少，所以使用“池”必须考虑面临的响应模式，
    并根据响应规模调整“池”的大小。
        对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可
    以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，
    但面临大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。

    非阻塞IO
    Linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，
    流程是这样的：
    当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是
    立刻返回一个error，从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到一个
    结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。
    一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝
    到了用户内存，然后返回，所以在非阻塞IO中，用户进程其他是需要不断的主动询问kernel数据准备好
    了没有。
        在非阻塞状态下，recv()接口在被调用之后立即返回，返回值代表不同的含义。如果在本例中，
    * recv() 返回值大于0，表示接受数据完毕，返回值即是接受到的字节数；
    * recv() 返回0，表示连接已正常断开；
    * recv() 返回-1，且errno等于EAGAIN，表示recv操作还没执行完成；
    * recv() 返回-1，且errno不等于EAGAIN，表示recv操作遇到系统错误errno
        非阻塞的接口相比于阻塞型接口的显著差异在于，在被调用之后立即返回。使用如下的函数可以将某
    句柄fd设为非阻塞状态。
        fcntl( fd, F_SETFL, O_NONBLOCK );
    下面将给出只用一个线程，但能够同时从多个连接中检测数据是否送达，并且接受数据的模型。
        服务器线程可以循环调用recv()接口，可以在单个线程内实现对所有连接的数据接收工作。但是上述
    模型绝不被推荐。因为，循环调用recv()将大幅度推高CPU占用率；此外，在这个方案中recv()更多的是
    起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成”作用的接口，例如
    select()多路复用模型，可以一次检测多个连接是否活跃。

    多路复用IO
    有些地方称这种IO方式为事件驱动IO，我们都知道，select/epoll的好处就在于单个process就可以同时
    处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所以socket,
    当某个socket有数据到达了，就通知用户流程。
        当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的
    socket，当任何一个socket中的数据准备好了，select就会返回，这个时候用户进程再调用read操作，
    将数据从kernel拷贝到用户进程。
        select比起blocking IO没有太大区别，甚至更差一些，因为它需要使用两个系统调用(select和read),
    而blocking IO只调用了一个系统调用(read)。但使用select最大的优势在于用户可以在一个线程内同时处理
    多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在
    同一线程内，同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。
    select/epoll的优势并不是对于单个连接能处理的更快，而是在于能处理更多的连接。
        在多路复用模型中，对于每一个socket，一般都设置为non-blocking，但是，如上图所示，整个用户的
    process其实是一直被block的，只不过process是被select这个函数block，而不是被socket IO给block。
    因此select()与非阻塞IO类似。
        大部分Unix/Linux都支持select函数，该函数用于探测多个文件句柄的状态变化。下面给出select接口的
    原型：
        FD_ZERO(int fd, fd_set *fds)
        FD_SET(int fd, fd_set *fds)
        FD_ISSET(int fd, fd_set *fds)
        FD_CLR(int fd, fd_set *fds)
        int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
        这里，fd_set类型可以简单的理解为按bit位标记句柄的队列，例如要在某fd_set中标记一个值为16的句柄，
    则该fd_set的第16个bit位被标记为1。具体的置为、验证可使用FD_SET、FD_ISSET等宏实现。在select()函数
    中，readfds、writefds和exceptfds同时作为输入参数和输出参数。如果输入的readfds标记了16号句柄，则
    select()将检测16号句柄是否可读。在select()返回后，可以通过检查readfds是否有表示16号句柄，来判断该
    “可读”事件是否发生。另外，用户可以设置timeout时间。
        下面将重新模拟上例中从多个客户端接收数据的模型。
        由于select()接口可以同时对多个句柄进行读状态、写状态和错误状态的探测，所以可以很容易构建为多个
    客户端独立提供问答服务的服务器系统。
        这里需要指出的是，客户端的一个connect()操作，将在服务器端激发一个“可读事件”，所以select()也能
    探测来自客户端的connect()行为。
        上述模型中，最关键的地方是如何动态维护select()的三个参数readfds、writefds和exceptfds。作为
    输入参数，readfds应该标记所有的需要探测的“可读事件”的句柄，其中永远包括那个探测connect()的那个“目”
    句柄；同时，writefds和exceptfds应该标记所有需要探测的“可写事件”和“错误事件”的句柄(使用FD_SET()标记)。
        作为输出参数，readfds、writefds和exceptfds中的保存了select()捕捉到的所有事件的句柄值。程序员需
    要检查所有的标记位(使用FD_ISSET()检查)，以确定到底哪些句柄发生了事件。
        如果select()发现某句柄捕捉到了“可读事件”，服务器程序应及时做recv()操作，并根据接收到的数据准备
    好待发送的数据，并将对应的句柄值加入writefds，准备下一次的“可写事件”的select()探测。同样，如果select()
    发现某句柄捕捉到“可写事件”，则程序应及时做send()操作，并准备好下一次的“可读事件”探测准备。
        这种模型的特征在于每一个执行周期都会探测一次或一组事件，一个特定的事件会触发某个特定的响应。我们可以
    将这种模型归类为“事件驱动模型”。
        相比其他模型，使用select()的事件驱动模型只用单线程(进程)执行，占用资源少，不消耗太多CPU，同时能够
    为多客户端提供服务。如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值。
        但这个模型依旧有着很多问题。首先select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值
    较大时，select()接口本身需要消耗大量的时间去轮询各个句柄。很多操作系统提供了更为高效的接口，如linux提供
    了epoll，BSD提供了kqueue，Solaris提供了/dev/poll，...。如果需要实现更高效的服务器程序，类似epoll这样
    的接口更被推荐。遗憾的是不同的操作系统提供的epoll接口有很大差异，所以类似于epoll的接口实现具有较好跨平台
    能力的服务器会比较困难。
        其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。如下例，
    庞大的执行体1的将直接导致响应事件2的执行体迟迟得不到执行，并在很大程度上降低了事件探测的及时性。
        幸运的是，有很多高效的事件驱动库可以屏蔽上述的困难，常见的事件驱动库有libevent库，还有作为libevent
    替代者的libev库。这些库会根据操作系统的特点选择最合适的事件探测接口，并且加入了信号(singal)等技术以支持
    异步响应，这使得这些库成为构建事件驱动模型的不二选择。

    异步IO
    Linux下的异步IO用在磁盘IO读写操作，不用于网络IO，从内核2.6版本才开始引入。
        用户进程发起read操作以后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它收到一个aio_read
    之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用
    户内存，当这一切都完成之后，kernel会给用户进程发送一个singal，告诉它read操作完成了。
        异步IO是真正非阻塞的，它不会对请求进程产生任何的阻塞，因此对高并发的网络服务器实现至关重要。

    信号驱动IO
        首先我们允许套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行，并不阻塞。当数据准备好时，进程
    会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。当数据准备好读取时，内核就为该进程产生一个
    SIGIO信号。我们随后既可以在信号处理函数中调用read读取数据报，并通知主循环数据已准备好待处理，也可以立即通知
    主循环，让它来读取数据报。无论如何处理SIGIO信号，这种模式的优势在于等待数据到达(第一阶段)期间，进程可以继续
    执行，不被阻塞。免去了select的阻塞与轮询，当有活跃套接字时，由注册的handler处理。

    服务器模型reactor与proactor
        对高并发编程，网络连接上的消息处理，可以分为两个阶段：等待消息准备好、消息处理。当使用默认的阻塞套接字时
    （例如上面提到的1个线程捆绑1个连接），往往是把这两个阶段合而为一，这样操作套接字的代码所在的线程就得睡眠来等
    待消息准备好，这导致了高并发下线程会频繁的睡眠、唤醒、从而影响了CPU的使用效率。
        高并发编程方法当然是把两个阶段分开处理。即，等待消息准备好的代码段，与处理消息的代码段是分离的。当然，这
    也要求套接字必须是非阻塞的，否则，处理消息的代码段很容易导致条件不满足时，所在线程又进入了睡眠等待阶段。那么
    问题来了，等待消息准备好这个阶段怎么实现？它毕竟还是等待，这意味着线程还是要睡眠的！解决办法是，线程主动查询，
    或者让1个线程为所有连接而等待！这就是IO多路复用了。多路复用就是处理等待消息准备好这个事的，但它可以同时处理
    多个连接！它也可能“等待”，所以它也会导致线程睡眠，然而这不要紧，因为它是一对多，它可以监听所有连接。这样，当
    我们的线程被唤醒执行时，就一定是有一些连接准备好被我们的代码执行了。
        作为一个高性能服务器程序通常需要考虑处理三类事件：I/O事件，定时器事件及信号。两种高效的事件处理模型：
    reactor和proactor。

    reactor模型：
        首先来回想一下普通函数调用的机制：程序调用某函数，函数执行，程序等待，函数将结果和控制权返回给程序，程序
    继续处理。reactor释义“反应堆”，是一种事件驱动机制。和普攻函数调用的不同之处在于：应用程序不是主动的调用某个
    api完成处理，而是恰恰相反，reactor逆置了事件处理流程，应用程序需要提供相应的接口并注册到reactor上，如果相应
    的时间发生，reactor将主动调用应用程序注册的接口，这些接口又被称为“回调函数”。
        reactor模式是处理并发IO比较常见的一种模式，用于同步IO，中心思想是将所有要处理的IO事件注册到一个中心IO多
    路复用器上，同时主线程/进程阻塞在多路复用器上；一旦有IO事件到来或是准备就绪（文件描述符或socket可读、写），
    多路复用器返回并将事先注册的相应的IO事件分发到对应的处理器中。
        reactor模型有三个重要的组件：
        1.多路复用器：由操作系统提供，在linux上一般是select,poll,epoll等系统调用。
        2.事件分发器：将多路复用器中返回的就绪事件分到对应的处理函数中。
        3.事件处理器：负责处理特定事件的处理函数。
    具体流程如下：
        1.注册读就绪事件和相应的事件处理器；
        2.事件分发器等待事件；
        3.事件到来，激活分发器，分发器调用对应的处理器；
        4.事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。
    reactor模式是编写高性能网络服务器的必备技术之一，它具有如下的优点：
        1.响应快，不必为单个同步时间所阻塞，虽然reactor本身依然是同步的；
        2.编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；
        3.可扩展性，可以方便的通过增加reactor实例个数来充分利用CPU资源；
        4.可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；
        reactor模型开发效率上比起直接使用IO复用要高，它通常是单线程的，设计目的是希望单线程使用一颗CPU的全部资源，
    但也附带优点，即每个事件处理中很多时候可以不考虑共享资源的互斥访问。可是缺点也是明显的，现在的硬件发展，已经
    不再遵循摩尔定律，CPU的频率受制于材料的限制不再有大的提升，而改为是从核数的增加上提升能力，当程序需要使用多核
    资源时，reactor模型就会悲剧，为什么呢？
        如果程序业务简单，例如只是简单的访问一些提供了并发访问的服务，就可以直接开启多个反应堆，每个反应堆对应一颗
    CPU核心，这些反应堆上跑的请求互不相关，这是完全可以利用多核的。例如Nginx这样的http静态服务器。

    proactor模型：
    具体流程如下：
    1.处理器发起异步操作，并关注I/O完成事件
    2.事件分离器等待操作完成事件
    3.分离器等待过程中，内核并行执行实际的I/O操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成
    4.I/O完成后，通知事件分离器呼唤
    5.事件处理器处理用户自定义缓冲区的数据
        proactor模型最大的特点就是使用异步IO。所有的IO操作都交由系统提供的异步IO接口去执行。工作线程仅仅负责业务
    逻辑。在proactor中，用户函数启动一个异步的文件操作。同时将这个操作注册到多路复用器上。多路复用器并不关心文件
    是否可读或可写而是关心这个异步操作是否完成。异步操作是操作系统完成，用户程序不需要关心。多路复用器等待直到有完
    成通知到来。当操作系统完成了读文件操作--将读到的数据复制到了用户先前提供的缓冲区之后，通过多路复用器相关操作已
    完成。多路复用器再调用相应的处理程序，处理数据。
        proactor增加了编程的复杂度，但给工作线程带来了更高的效率。proactor可以在系统太将读写优化，利用IO并行能力，
    提供一个高性能单线程模型。在windows上，由于没有epoll这样的机制，因此提供了IOCP来支持高并发，由于操作系统做了
    较好的优化，windows较常采用proactor的模型利用完成端口来实现服务器。在linux上，在2.6内核出现了aio接口，但aio
    实际效果并不理想，它的出现，主要是解决poll性能不佳的问题，但实际上经过测试，epoll的性能高于poll+aio，并且aio
    不能处理accept，因此linux主要还是以reactor模型为主。
        在不使用操作系统提供的异步IO接口的情况下，还可以使用reactor来模拟proactor，差别是：使用异步接口可以利用
    系统提供的读写并行能力，而在模拟的情况下，这需要在用户态实现。具体的做法只需要这样：
        1.注册读事件（同时再提供一段缓冲区）
        2.事件分离器等待可读事件
        3.事件到来，激活分离器，分离器（立即读数据，写缓冲区）调用事件处理器
        4.事件处理器处理数据，删除事件（需要再用异步接口注册）
        我们知道，boost.asio库采用的即为proactor模型。不过boost.asio库在linux平台采用epoll实现的reactor来模拟
    proactor，并且另外开了一个线程来完成读写调度。

    同步IO模拟proactor模型
    1.主线程往epoll内核事件表中注册socket上的读就绪事件。
    2.主线程调用epoll_wait等待socket上有数据可读。
    3.当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取
      到的数据封装成一个请求对象并插入请求队列。
    4.睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写
      就绪事件。
    5.主线程调用epoll_wait等待socket可写。
    6.当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。
        两个模式的相同点，都是对某个IO事件的事件通知（即告诉某个模块，这个IO操作可以进行或已经完成）。在结构上两者
    也有相同点：demultiplexor负责提交IO操作（异步）、查询设备是否可操作（同步），然后当条件满足时，就回调注册处理
    函数。
        不同点在于，异步情况下（proactor），当回调注册的处理函数时，表示IO操作已经完成；同步情况下（reactor），回
    调注册的处理函数时，表示IO设备可以进行某个操作（can read or can write），注册的处理函数这个时候开始提交操作。
*/